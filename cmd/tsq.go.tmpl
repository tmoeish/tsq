{{- $dot := . }}
{{- $type := .TypeInfo.TypeName }}
{{- $varTbl := printf "Table%s" $type }}
{{- $varTblCols := printf "Table%sCols" $type }}
{{- $ptype := printf "*%s" $type }}
{{- $list := printf "[]*%s" $type }}
{{- $pageResp := printf "tsq.PageResp[%s]" $type }}

{{- $recv := printf "func (%s %s) " .Recv $type }}
{{- $precv := printf "func (%s *%s) " .Recv $type }}

{{- $getBy := printf "get%sBy" $type }}
{{- $GetBy := printf "Get%sBy" $type }}
{{- $ExistsBy := printf "Exists%sBy" $type }}

{{- $getActiveBy := printf "getActive%sBy" $type }}
{{- $GetActiveBy := printf "GetActive%sBy" $type }}
{{- $ExistsActiveBy := printf "ExistsActive%sBy" $type }}

{{- $CountBy := printf "Count%sBy" $type }}
{{- $ListBy := printf "List%sBy" $type }}
{{- $PageBy := printf "Page%sBy" $type }}

{{- $CountActiveBy := printf "CountActive%sBy" $type }}
{{- $listActiveBy := printf "listActive%sBy" $type }}
{{- $ListActiveBy := printf "ListActive%sBy" $type }}
{{- $PageActiveBy := printf "PageActive%sBy" $type }}

// Code generated by tsq-{{.TSQVersion}}. DO NOT EDIT.
package {{.TypeInfo.Package.Name}}

import (
	"context"
	"github.com/tmoeish/tsq"
	"github.com/juju/errors"
	"gopkg.in/gorp.v2"
	"database/sql"
{{- range $p, $a := .ImportMap }}
	{{$a}} "{{$p}}"
{{- end }}
{{- if or .CT .MT .DT }}
{{- if not .ImportMap.time }}
	"time"
{{- end }}
{{- end }}
)

// =============================================================================
// Table Interface Implementation
// =============================================================================

func init() {
	tsq.RegisterTable(Table{{$type}})
}

// {{$varTbl}} implements the tsq.Table interface for {{$type}}.
var {{$varTbl}} tsq.Table = {{$type}}{}

// {{$varTblCols}} is the list of columns for {{$type}} table.
var {{$varTblCols}} = []tsq.Column{
{{- range $f := .Fields }}
	{{$type}}_{{$f.Name}},
{{- end }}
}

// Column definitions for {{$type}} table.
var (
{{- range $f := .Fields }}
	{{$type}}_{{$f.Name}} = tsq.NewCol[{{$f | FieldType}}]({{$varTbl}}, "{{$f.Column}}", "{{$f.JsonTag}}", func(t any) any {
			return &t.({{$ptype}}).{{$f.Name}}
	})
{{- end }}
)

// Init initializes the {{$type}} table in the database.
func ({{$dot.Recv}} {{$type}}) Init(db *gorp.DbMap, upsertIndexies bool) error {
	db.AddTableWithName({{$dot.Recv}}, "{{ $dot.Table }}").SetKeys({{ if $dot.AI }}true{{ else }}false{{ end }}, "{{ $dot.ID }}"){{ if $dot.V }}.SetVersionCol("{{ $dot.V }}") {{ end }}

	if !upsertIndexies {
		return nil
	}

{{if $dot.UxList }}
	// Upsert Ux list
	{{- range $name, $idx := $dot.UxList }}
	if err := tsq.UpsertIndex(db, "{{ $dot.Table }}", true, "{{$idx.Name}}", {{ (FiledsToColsGoSlice $dot $idx.Fields) }}); err != nil {
		return errors.Annotatef(err, "upsert ux %s for %s", "{{$idx.Name}}", {{ $.Recv }}.Table())
	}
	{{- end }}
{{- end }}

{{- if $dot.IdxList }}
	// Upsert Idx list
	{{- range $name, $idx := $dot.IdxList }}
	if err := tsq.UpsertIndex(db, "{{ $dot.Table }}", false, "{{$idx.Name}}", {{ (FiledsToColsGoSlice $dot $idx.Fields) }}); err != nil {
		return errors.Annotatef(err, "upsert idx %s for %s", "{{$idx.Name}}", {{ $.Recv }}.Table())
	}
	{{- end }}
{{- end }}

	return nil
}

// Table returns the database table name for {{$type}}.
func ({{$dot.Recv}} {{$type}}) Table() string               { return "{{$dot.Table}}" }

// KwList returns columns that support keyword search for {{$type}}.
func ({{$dot.Recv}} {{$type}}) KwList() []tsq.Column {
	return []tsq.Column{
	{{- range $f := .KwList }}
		{{$type}}_{{$f}},
	{{- end }}
	}
}



{{- if .DT }}
// Active returns true if the {{$type}} record is not soft-deleted.
{{$precv}}Active() bool {
	return {{$dot.Recv}}.{{$dot.DT}} == 0
}
{{- end }}

// =============================================================================
// Query by Primary Key
// =============================================================================

{{- with $query := printf "%s%sQuery" $getBy $dot.ID }}
var {{$query}} = tsq.
	Select({{$varTblCols}}...).
	Where(
		{{$type}}_{{$dot.ID}}.EQVar(),
	).
	MustBuild()

	{{- with $name := printf "%s%s" $GetBy $dot.ID }}
// {{$name}} retrieves a {{$type}} record by its {{$dot.ID}}.
// Returns (nil, nil) if the record is not found.
func {{$name}}(
	ctx context.Context,
	db gorp.SqlExecutor,
	{{$dot.ID | ToLower}} {{index $dot.FieldMap $dot.ID | FieldType}},
) ({{$ptype}}, error) {
	row := &{{$type}}{}
	return row, tsq.Trace(ctx, func(ctx context.Context) error {
		err := {{$query}}.Load(ctx, db, row, {{$dot.ID | ToLower}})
		switch errors.Cause(err) {
		case nil:
			return nil
		case sql.ErrNoRows:
			row = nil
			return nil
		default:
			return errors.Trace(err)
		}
	})
}
	{{- end }}

	{{- with $name := printf "%s%sOrErr" $GetBy $dot.ID }}
// {{$name}} retrieves a {{$type}} record by its {{$dot.ID}}.
// Returns (nil, sql.ErrNoRows) if the record is not found.
func {{$name}}(
	ctx context.Context,
	db gorp.SqlExecutor,
	{{$dot.ID | ToLower}} {{index $dot.FieldMap $dot.ID | FieldType}},
) ({{$ptype}}, error) {
	row := &{{$type}}{}
	err := tsq.Trace(ctx, func(ctx context.Context) error {
		return {{$query}}.Load(
			ctx, db, row, {{$dot.ID | ToLower}},
		)
	})
	return row, errors.Trace(err)
}
	{{- end }}
{{- end }}

{{- with $name := printf "%s%sIn" $ListBy $dot.ID }}
// {{$name}} retrieves multiple {{$type}} records by a set of {{$dot.ID}} values.
// Records not found are silently ignored.
func {{$name}}(
	ctx context.Context,
	db gorp.SqlExecutor,
	{{$dot.ID | ToLower}}s ...{{index $dot.FieldMap $dot.ID | FieldType}},
) ({{$list}}, error) {
	query := tsq.
		Select({{$varTblCols}}...).
		Where({{$type}}_{{$dot.ID}}.In({{$dot.ID | ToLower}}s...)).
		MustBuild()

	var list {{$list}}
	return list, tsq.Trace(ctx, func(ctx context.Context) error {
		var err error
		list, err = tsq.List[{{$type}}](
			ctx, db, query,
		)
		if err != nil {
			return errors.Trace(err)
		}
		return nil
	})
}
{{- end }}

{{- with $name := printf "%s%sInOrErr" $ListBy $dot.ID }}
// {{$name}} retrieves multiple {{$type}} records by a set of {{$dot.ID}} values.
// Returns an error if any of the specified records are not found.
func {{$name}}(
	ctx context.Context,
	db gorp.SqlExecutor,
	{{$dot.ID | ToLower}}s ...{{index $dot.FieldMap $dot.ID | FieldType}},
) ({{$list}}, error) {
	{{$dot.ID | ToLower}}Set := map[{{index $dot.FieldMap $dot.ID | FieldType}}]bool{}
	for _, i := range {{$dot.ID | ToLower}}s {
		{{$dot.ID | ToLower}}Set[i] = true
	}
	query := tsq.
		Select({{$varTblCols}}...).
		Where({{$type}}_{{$dot.ID}}.In({{$dot.ID | ToLower}}s...)).
		MustBuild()
	var list {{$list}}
	return list, tsq.Trace(ctx, func(ctx context.Context) error {
		var err error
		list, err = tsq.List[{{$type}}](
			ctx, db, query,
		)
		if err != nil {
			return errors.Trace(err)
		}

		for _, i := range list {
			delete({{$dot.ID | ToLower}}Set, i.{{$dot.ID}})
		}
		if len({{$dot.ID | ToLower}}Set) > 0 {
			var missings []{{index $dot.FieldMap $dot.ID | FieldType}}
			for i := range {{$dot.ID | ToLower}}Set {
				missings = append(missings, i)
			}
			return errors.Errorf("{{$type}}(s) not found: %v", missings)
		}
		return nil
	})
}
{{- end }}

{{- if .DT }}
// =============================================================================
// Query Active Records by Primary Key
// =============================================================================

	{{- with $query := printf "%s%sQuery" $getActiveBy $dot.ID }}
var {{$query}} = tsq.
	Select({{$varTblCols}}...).
	Where(
		{{$type}}_{{$dot.DT}}.EQ(0),
		{{$type}}_{{$dot.ID}}.EQVar(),
	).
	MustBuild()

		{{- with $name := printf "%s%s" $GetActiveBy $dot.ID }}
// {{$name}} retrieves an active (non-deleted) {{$type}} record by its {{$dot.ID}}.
// Returns (nil, nil) if the record is not found or has been soft-deleted.
func {{$name}}(
	ctx context.Context,
	db gorp.SqlExecutor,
	{{$dot.ID | ToLower}} {{index $dot.FieldMap $dot.ID | FieldType}},
) ({{$ptype}}, error) {
	row := &{{$type}}{}
	return row, tsq.Trace(ctx, func(ctx context.Context) error {
		err := {{$query}}.Load(ctx, db, row, {{$dot.ID | ToLower}})
		switch errors.Cause(err) {
		case nil:
			return nil
		case sql.ErrNoRows:
			row = nil
			return nil
		default:
			return errors.Trace(err)
		}
	})
}
		{{- end }}

		{{- with $name := printf "%s%sOrErr" $GetActiveBy $dot.ID }}
// {{$name}} retrieves an active (non-deleted) {{$type}} record by its {{$dot.ID}}.
// Returns (nil, sql.ErrNoRows) if the record is not found or has been soft-deleted.
func {{$name}}(
	ctx context.Context,
	db gorp.SqlExecutor,
	{{$dot.ID | ToLower}} {{index $dot.FieldMap $dot.ID | FieldType}},
) ({{$ptype}}, error) {
	row := &{{$type}}{}
	err := tsq.Trace(ctx, func(ctx context.Context) error {
		return {{$query}}.Load(ctx, db, row, {{$dot.ID | ToLower}})
	})
	return row, errors.Trace(err)
}
		{{- end }}
	{{- end }}

	{{- with $name := printf "%s%sIn" $ListActiveBy $dot.ID }}
// {{$name}} retrieves multiple active (non-deleted) {{$type}} records by a set of {{$dot.ID}} values.
// Records not found or soft-deleted are silently ignored.
func {{$name}}(
	ctx context.Context,
	db gorp.SqlExecutor,
	{{$dot.ID | ToLower}}s ...{{index $dot.FieldMap $dot.ID | FieldType}},
) ({{$list}}, error) {
	query := tsq.
		Select({{$varTblCols}}...).
		Where(
			{{$type}}_{{$dot.DT}}.EQ(0),
			{{$type}}_{{$dot.ID}}.In({{$dot.ID | ToLower}}s...),
		).
		MustBuild()
	var list {{$list}}
	err := tsq.Trace(ctx, func(ctx context.Context) error {
		var err error
		list, err = tsq.List[{{$type}}](ctx, db, query)
		if err != nil {
			return errors.Trace(err)
		}
		return nil
	})
	return list, errors.Trace(err)
}
	{{- end }}

	{{- with $name := printf "%s%sInOrErr" $ListActiveBy $dot.ID }}
// {{$name}} retrieves multiple active (non-deleted) {{$type}} records by a set of {{$dot.ID}} values.
// Returns an error if any of the specified active records are not found.
func {{$name}}(
	ctx context.Context,
	db gorp.SqlExecutor,
	{{$dot.ID | ToLower}}s ...{{index $dot.FieldMap $dot.ID | FieldType}},
) ({{$list}}, error) {
	{{$dot.ID | ToLower}}Set := map[{{index $dot.FieldMap $dot.ID | FieldType}}]bool{}
	for _, i := range {{$dot.ID | ToLower}}s {
		{{$dot.ID | ToLower}}Set[i] = true
	}
	query := tsq.
		Select({{$varTblCols}}...).
		Where(
			{{$type}}_{{$dot.DT}}.EQ(0),
			{{$type}}_{{$dot.ID}}.In({{$dot.ID | ToLower}}s...),
		).
		MustBuild()

	var list {{$list}}
	return list, tsq.Trace(ctx, func(ctx context.Context) error {
		var err error
		list, err = tsq.List[{{$type}}](ctx, db, query)
		if err != nil {
			return errors.Trace(err)
		}
		for _, i := range list {
			delete({{$dot.ID | ToLower}}Set, i.{{$dot.ID}})
		}
		if len({{$dot.ID | ToLower}}Set) > 0 {
			var missings []{{index $dot.FieldMap $dot.ID | FieldType}}
			for i := range {{$dot.ID | ToLower}}Set {
				missings = append(missings, i)
			}
			return errors.Errorf("{{$type}}(s) not found: %v", missings)
		}
		return nil
	})
}
	{{- end }}
{{- end }}

// =============================================================================
// CRUD Operations
// =============================================================================

// Insert inserts a new {{$type}} record into the database.
// Automatically sets creation and modification timestamps if configured.
{{$precv}}Insert(
	ctx context.Context,
	db gorp.SqlExecutor,
) error {
	return tsq.Trace(ctx, func(ctx context.Context) error {
{{- if $dot.CT }}
	{{- $pkg := index $dot.FieldMap $dot.CT }}
	{{- if eq "time" $pkg.Type.Package.Path }}
		{{$dot.Recv}}.{{$dot.CT}} = time.Now()
	{{- else }}
		{{$dot.Recv}}.{{$dot.CT}} = null.TimeFrom(time.Now())
	{{- end }}
{{- end }}
{{- if $dot.MT }}
	{{- $pkg := index $dot.FieldMap $dot.MT }}
	{{- if eq "time" $pkg.Type.Package.Path }}
		{{$dot.Recv}}.{{$dot.MT}} = time.Now()
	{{- else }}
		{{$dot.Recv}}.{{$dot.MT}} = null.TimeFrom(time.Now())
	{{- end }}
{{- end }}
		err := db.Insert({{$dot.Recv}})
		if err != nil {
			return errors.Annotate(err, tsq.PrettyJSON({{$dot.Recv}}))
		}

		return nil
	})
}

// Update updates an existing {{$type}} record in the database.
// Automatically updates the modification timestamp if configured.
{{$precv}}Update(
	ctx context.Context,
	db gorp.SqlExecutor,
) error {
	return tsq.Trace(ctx, func(ctx context.Context) error {
{{- if $dot.MT }}
	{{- $pkg := index $dot.FieldMap $dot.MT }}
	{{- if eq "time" $pkg.Type.Package.Path }}
		{{$dot.Recv}}.{{$dot.MT}} = time.Now()
	{{- else }}
		{{$dot.Recv}}.{{$dot.MT}} = null.TimeFrom(time.Now())
	{{- end }}
{{- end }}
		_, err := db.Update({{$dot.Recv}})
		if err != nil {
			return errors.Annotate(err, tsq.PrettyJSON({{$dot.Recv}}))
		}

		return nil
	})
}

// Delete permanently removes a {{$type}} record from the database.
{{$precv}}Delete(
	ctx context.Context,
	db gorp.SqlExecutor,
) error {
	return tsq.Trace(ctx, func(ctx context.Context) error {
		_, err := db.Delete({{$dot.Recv}})
		if err != nil {
			return errors.Annotate(err, tsq.PrettyJSON({{$dot.Recv}}))
		}

		return nil
	})
}

{{- if .DT }}
// SoftDelete marks a {{$type}} record as deleted without removing it from the database.
// If dt > 0, uses the provided timestamp; otherwise uses the current time.
{{$precv}}SoftDelete(
	ctx context.Context,
	db gorp.SqlExecutor,
	dt int64,
) error {
	return tsq.Trace(ctx, func(ctx context.Context) error {
		if dt > 0 {
			{{$dot.Recv}}.{{$dot.DT}} = dt
		} else {
			{{$dot.Recv}}.{{$dot.DT}} = time.Now().UnixNano()
		}
	{{- if $dot.MT }}
		{{- $pkg := index $dot.FieldMap $dot.MT }}
		{{- if eq "time" $pkg.Type.Package.Path }}
		{{$dot.Recv}}.{{$dot.MT}} = time.Now()
		{{- else }}
		{{$dot.Recv}}.{{$dot.MT}} = null.TimeFrom(time.Now())
		{{- end }}
	{{- end }}
		_, err := db.Update({{$dot.Recv}})
		if err != nil {
			return errors.Annotate(err, tsq.PrettyJSON({{$dot.Recv}}))
		}

		return nil
	})
}
{{- end }}

{{- with $name := printf "%sQuery" $ListBy }}
// {{$name}} executes a custom query to retrieve {{$type}} records.
func {{$name}}(
	ctx context.Context,
	tx gorp.SqlExecutor,
	qb *tsq.Query,
	args ...any,
) ({{$list}}, error) {
	var data {{$list}}
	return data, tsq.Trace(ctx, func(ctx context.Context) error {
		var err error
		data, err = tsq.List[{{$type}}](ctx, tx, qb, args...)
		return errors.Trace(err)
	})
}
{{- end }}

{{- with $name := printf "%sQuery" $PageBy }}
// {{$name}} executes a custom query with pagination to retrieve {{$type}} records.
func {{$name}}(
	ctx context.Context,
	tx gorp.SqlExecutor,
	page *tsq.PageReq,
	qb *tsq.Query,
	args ...any,
) (*{{$pageResp}}, error) {
	var rs *{{$pageResp}}
	return rs, tsq.Trace(ctx, func(ctx context.Context) error {
		var err error
		rs, err = tsq.Page[{{$type}}](
			ctx, tx, page, qb, args...
		)
		return errors.Trace(err)
	})
}
{{- end }}

// =============================================================================
// List All Records
// =============================================================================

{{- with $query := printf "list%sQuery" $type }}
// {{$query}} is the base query for retrieving all {{$type}} records.
var {{$query}} = tsq.
	Select({{$varTblCols}}...).
	KwSearch(Table{{$type}}.KwList()...).
	MustBuild()

	{{- with $name := printf "Count%s" $type }}
// {{$name}} returns the total count of {{$type}} records.
func {{$name}}(
	ctx context.Context,
	tx gorp.SqlExecutor,
) (int, error) {
	query := {{$query}}

	var rs int
	return rs, tsq.Trace(ctx, func(ctx context.Context) error {
		var err error
		rs, err = query.Count(ctx, tx)
		return errors.Trace(err)
	})
}
	{{- end }}

	{{- with $name := printf "List%s" $type }}
// {{$name}} retrieves all {{$type}} records from the database.
func {{$name}}(
	ctx context.Context,
	tx gorp.SqlExecutor,
) ({{$list}}, error) {
	query := {{$query}}

	var data {{$list}}
	return data, tsq.Trace(ctx, func(ctx context.Context) error {
		var err error
		data, err = tsq.List[{{$type}}](ctx, tx, query)
		return errors.Trace(err)
	})
}
	{{- end }}

	{{- with $name := printf "Page%s" $type }}
// {{$name}} retrieves {{$type}} records with pagination support.
func {{$name}}(
	ctx context.Context,
	tx gorp.SqlExecutor,
	page *tsq.PageReq,
) (*{{$pageResp}}, error) {
	query := {{$query}}

	var rs *{{$pageResp}}
	return rs, tsq.Trace(ctx, func(ctx context.Context) error {
		var err error
		rs, err = tsq.Page[{{$type}}](
			ctx, tx, page, query,
		)
		return errors.Trace(err)
	})
}
	{{- end }}
{{- end }}

{{- if .DT }}
// =============================================================================
// List Active Records
// =============================================================================

	{{- with $query := printf "listActive%sQuery" $type }}
// {{$query}} is the base query for retrieving active (non-deleted) {{$type}} records.
var {{$query}} = tsq.
	Select({{$varTblCols}}...).
	Where({{$type}}_{{$dot.DT}}.EQ(0)).
	KwSearch(Table{{$type}}.KwList()...).
	MustBuild()

		{{- with $name := printf "CountActive%s" $type }}
// {{$name}} returns the count of active (non-deleted) {{$type}} records.
func {{$name}}(
	ctx context.Context,
	tx gorp.SqlExecutor,
) (int, error) {
	query := {{$query}}

	var rs int
	return rs, tsq.Trace(ctx, func(ctx context.Context) error {
		var err error
		rs, err = query.Count(ctx, tx)
		return errors.Trace(err)
	})
}
		{{- end }}

		{{- with $name := printf "ListActive%s" $type }}
// {{$name}} retrieves all active (non-deleted) {{$type}} records.
func {{$name}}(
	ctx context.Context,
	tx gorp.SqlExecutor,
) ({{$list}}, error) {
	query := {{$query}}

	var data {{$list}}
	return data, tsq.Trace(ctx, func(ctx context.Context) error {
		var err error
		data, err = tsq.List[{{$type}}](ctx, tx, query)
		return errors.Trace(err)
	})
}
		{{- end }}

		{{- with $name := printf "PageActive%s" $type }}
// {{$name}} retrieves active (non-deleted) {{$type}} records with pagination support.
func {{$name}}(
	ctx context.Context,
	tx gorp.SqlExecutor,
	page *tsq.PageReq,
) (*{{$pageResp}}, error) {
	query := {{$query}}

	var rs *{{$pageResp}}
	return rs, tsq.Trace(ctx, func(ctx context.Context) error {
		var err error
		rs, err = tsq.Page[{{$type}}](
			ctx, tx, page, query,
		)
		return errors.Trace(err)
	})
}
		{{- end }}
	{{- end }}
{{- end }}

// =============================================================================
// Query by Unique Indexes
// =============================================================================

{{- range $ux := .UxList }}
	{{- with $query := printf "%s%sQuery" $getBy (JoinAnd $ux.Fields) }}
var {{$query}} = tsq.
	Select({{$varTblCols}}...).
	Where(
		{{- range $f := $ux.Fields }}
		{{$type}}_{{$f}}.EQVar(),
		{{- end }}
	).
	KwSearch(Table{{$type}}.KwList()...).
	MustBuild()

		{{- with $name := printf "%s%s" $GetBy (JoinAnd $ux.Fields) }}
// {{$name}} retrieves a {{$type}} record by unique index {{$ux.Name}}.
// Returns (nil, nil) if the record is not found.
func {{$name}}(
	ctx context.Context,
	db gorp.SqlExecutor,
			{{- range $f := $ux.Fields }}
	{{$f | LowerInitial}} {{ index $dot.FieldMap $f | FieldType }},
			{{- end }}
) ({{$ptype}}, error) {
	query := {{$query}}

	row := &{{$type}}{}
	return row, tsq.Trace(ctx, func(ctx context.Context) error {
		err := query.Load(ctx, db, row,
			{{- range $f := $ux.Fields }}
			{{$f | LowerInitial}},
			{{- end }}
		)
		switch errors.Cause(err) {
		case nil:
			return nil
		case sql.ErrNoRows:
			row = nil
			return nil
		default:
			return errors.Trace(err)
		}
	})
}
		{{- end }}

		{{- with $name := printf "%s%sOrErr" $GetBy (JoinAnd $ux.Fields) }}
// {{$name}} retrieves a {{$type}} record by unique index {{$ux.Name}}.
// Returns (nil, sql.ErrNoRows) if the record is not found.
func {{$name}}(
	ctx context.Context,
	db gorp.SqlExecutor,
			{{- range $f := $ux.Fields }}
	{{$f | LowerInitial}} {{ index $dot.FieldMap $f | FieldType }},
			{{- end }}
) ({{$ptype}}, error) {
	query := {{$query}}

	row := &{{$type}}{}
	return row, tsq.Trace(ctx, func(ctx context.Context) error {
		return query.Load(ctx, db, row,
			{{- range $f := $ux.Fields }}
			{{$f | LowerInitial}},
			{{- end }}
		)
	})
}
		{{- end }}

		{{- with $name := printf "%s%s" $ExistsBy (JoinAnd $ux.Fields) }}
// {{$name}} checks whether a {{$type}} record exists by unique index {{$ux.Name}}.
func {{$name}}(
	ctx context.Context,
	db gorp.SqlExecutor,
			{{- range $f := $ux.Fields }}
	{{$f | LowerInitial}} {{ index $dot.FieldMap $f | FieldType }},
			{{- end }}
) (bool, error) {
	query := {{$query}}

	var rs bool
	return rs, tsq.Trace(ctx, func(ctx context.Context) error {
		var err error
		rs, err = query.Exists(ctx, db,
			{{- range $f := $ux.Fields }}
			{{$f | LowerInitial}},
			{{- end }}
		)
		return errors.Trace(err)
	})
}
		{{- end }}
	{{- end }}
{{- end }}

{{- if .DT }}
// =============================================================================
// Query Active Records by Unique Indexes
// =============================================================================

	{{- range $ux := .UxList }}
		{{- with $query := printf "%s%sQuery" $getActiveBy (JoinAnd $ux.Fields) }}
// {{$query}} queries active (non-deleted) {{$type}} records by unique index {{$ux.Name}}.
var {{$query}} = tsq.
	Select({{$varTblCols}}...).
	Where(
		{{$type}}_{{$dot.DT}}.EQ(0),
			{{- range $f := $ux.Fields }}
		{{$type}}_{{$f}}.EQVar(),
			{{- end }}
	).
	KwSearch(Table{{$type}}.KwList()...).
	MustBuild()

			{{- with $name := printf "%s%s" $GetActiveBy (JoinAnd $ux.Fields) }}
// {{$name}} retrieves an active (non-deleted) {{$type}} record by unique index {{$ux.Name}}.
// Returns (nil, nil) if the record is not found or has been soft-deleted.
func {{$name}}(
	ctx context.Context,
	db gorp.SqlExecutor,
				{{- range $f := $ux.Fields }}
	{{$f | LowerInitial}} {{ index $dot.FieldMap $f | FieldType }},
				{{- end }}
) ({{$ptype}}, error) {
	query := {{$query}}

	row := &{{$type}}{}
	return row, tsq.Trace(ctx, func(ctx context.Context) error {
		err := query.Load(ctx, db, row,
				{{- range $f := $ux.Fields }}
			{{$f | LowerInitial}},
				{{- end }}
		)
		switch errors.Cause(err) {
		case nil:
			return nil
		case sql.ErrNoRows:
			row = nil
			return nil
		default:
			return errors.Trace(err)
		}
	})
}
			{{- end }}

			{{- with $name := printf "%s%sOrErr" $GetActiveBy (JoinAnd $ux.Fields) }}
// {{$name}} retrieves an active (non-deleted) {{$type}} record by unique index {{$ux.Name}}.
// Returns (nil, sql.ErrNoRows) if the record is not found or has been soft-deleted.
func {{$name}}(
	ctx context.Context,
	db gorp.SqlExecutor,
				{{- range $f := $ux.Fields }}
	{{$f | LowerInitial}} {{ index $dot.FieldMap $f | FieldType }},
				{{- end }}
) ({{$ptype}}, error) {
	query := {{$query}}

	row := &{{$type}}{}
	return row, tsq.Trace(ctx, func(ctx context.Context) error {
		return query.Load(ctx, db, row,
				{{- range $f := $ux.Fields }}
			{{$f | LowerInitial}},
				{{- end }}
		)
	})
}
			{{- end }}

			{{- with $name := printf "%s%s" $ExistsActiveBy (JoinAnd $ux.Fields) }}
// {{$name}} checks whether an active (non-deleted) {{$type}} record exists by unique index {{$ux.Name}}.
func {{$name}}(
	ctx context.Context,
	db gorp.SqlExecutor,
				{{- range $f := $ux.Fields }}
	{{$f | LowerInitial}} {{ index $dot.FieldMap $f | FieldType }},
				{{- end }}
) (bool, error) {
	query := {{$query}}

	var rs bool
	return rs, tsq.Trace(ctx, func(ctx context.Context) error {
		var err error
		rs, err = query.Exists(ctx, db,
				{{- range $f := $ux.Fields }}
			{{$f | LowerInitial}},
				{{- end }}
		)
		return errors.Trace(err)
	})
}
			{{- end }}
		{{- end }}
	{{- end }}
{{- end }}

{{- if .QueryList }}
// =============================================================================
// Query by Indexes
// =============================================================================
{{- end }}

{{- range $idx := .QueryList }}
	{{- if $idx.IsSet }}
	// List{{$type}}By{{$idx.Name}} retrieves {{$type}} records by index {{$idx.Name}} using IN clause for batch querying.
func List{{$type}}By{{$idx.Name}}(
	ctx context.Context,
	db gorp.SqlExecutor,
		{{- range $i, $f := $idx.Fields }}
			{{- if eq $i (Sub1 (len $idx.Fields)) }}
	{{ $f | LowerInitial }}s ...{{ (index $.FieldMap $f) | FieldType }},
			{{- else }}
	{{ $f | LowerInitial }} {{ (index $.FieldMap $f) | FieldType }},
			{{- end }}
		{{- end }}
) ({{$list}}, error) {
	query := tsq.
		Select({{$varTblCols}}...).
		Where(
		{{- range $i, $f := $idx.Fields }}
			{{- if eq $i (Sub1 (len $idx.Fields)) }}
			{{$type}}_{{$f}}.In({{ $f | LowerInitial }}s...),
			{{- else }}
			{{$type}}_{{$f}}.EQ({{ $f | LowerInitial }}),
			{{- end }}
		{{- end }}
		).
		MustBuild()
	var list {{$list}}
	err := tsq.Trace(ctx, func(ctx context.Context) error {
		var err error
		list, err = tsq.List[{{$type}}](ctx, db, query)
		return errors.Trace(err)
	})
	return list, errors.Trace(err)
}
	{{- else }}
		{{- with $query := printf "%s%sQuery" $ListBy $idx.Name }}
// {{$query}} queries {{$type}} records by index {{$idx.Name}}.
var {{$query}} = tsq.
	Select({{$varTblCols}}...).
	Where(
			{{- range $f := $idx.Fields }}
		{{$type}}_{{$f}}.EQVar(),
			{{- end }}
	).
	KwSearch(Table{{$type}}.KwList()...).
	MustBuild()

			{{- with $name := printf "%s%s" $CountBy $idx.Name }}
// {{$name}} returns the count of {{$type}} records matching index {{$idx.Name}}.
func {{$name}}(
	ctx context.Context,
	db gorp.SqlExecutor,
				{{- range $f := $idx.Fields }}
	{{$f | LowerInitial}} {{ index $dot.FieldMap $f | FieldType }},
				{{- end }}
) (int, error) {
	query := {{$query}}

	var rs int
	return rs, tsq.Trace(ctx, func(ctx context.Context) error {
		var err error
		rs, err = query.Count(ctx, db,
				{{- range $f := $idx.Fields }}
			{{$f | LowerInitial}},
				{{- end }}
		)
		return errors.Trace(err)
	})
}
			{{- end }}

			{{- with $name := printf "%s%s" $ListBy $idx.Name }}
// {{$name}} retrieves {{$type}} records by index {{$idx.Name}}.
func {{$name}}(
	ctx context.Context,
	db gorp.SqlExecutor,
				{{- range $f := $idx.Fields }}
	{{$f | LowerInitial}} {{ index $dot.FieldMap $f | FieldType }},
				{{- end }}
) ({{$list}}, error) {
	query := {{$query}}

	var data {{$list}}
	return data, tsq.Trace(ctx, func(ctx context.Context) error {
		var err error
		data, err = tsq.List[{{$type}}](ctx, db, query,
				{{- range $f := $idx.Fields }}
			{{$f | LowerInitial}},
				{{- end }}
		)
		return errors.Trace(err)
	})
}
			{{- end }}

			{{- with $name := printf "%s%s" $PageBy $idx.Name }}
// {{$name}} retrieves {{$type}} records by index {{$idx.Name}} with pagination support.
func {{$name}}(
	ctx context.Context,
	db gorp.SqlExecutor,
	page *tsq.PageReq,
				{{- range $f := $idx.Fields }}
	{{$f | LowerInitial}} {{ index $dot.FieldMap $f | FieldType }},
				{{- end }}
) (*{{$pageResp}}, error) {
	query := {{$query}}

	var rs *{{$pageResp}}
	return rs, tsq.Trace(ctx, func(ctx context.Context) error {
		var err error
		rs, err = tsq.Page[{{$type}}](ctx, db, page, query,
				{{- range $f := $idx.Fields }}
			{{$f | LowerInitial}},
				{{- end }}
		)
		return errors.Trace(err)
	})
}
			{{- end }}
		{{- end }}
	{{- end }}
{{- end }}

{{- if .DT }}
// =============================================================================
// Query Active Records by Indexes
// =============================================================================

	{{- range $idx := .QueryList }}
		{{- if $idx.IsSet }}
			{{- with $name := printf "%s%s" $ListActiveBy $idx.Name }}
// {{$name}} retrieves active (non-deleted) {{$type}} records by index {{$idx.Name}} using IN clause for batch querying.
func {{$name}}(
	ctx context.Context,
	db gorp.SqlExecutor,
				{{- range $i, $f := $idx.Fields }}
					{{- if eq $i (Sub1 (len $idx.Fields)) }}
	{{ $f | LowerInitial }}s ...{{ (index $.FieldMap $f) | FieldType }},
					{{- else }}
	{{ $f | LowerInitial }} {{ (index $.FieldMap $f) | FieldType }},
					{{- end }}
				{{- end }}
) ({{$list}}, error) {
	query := tsq.
		Select({{$varTblCols}}...).
		Where(
			{{$type}}_{{$dot.DT}}.EQ(0),
				{{- range $i, $f := $idx.Fields }}
					{{- if eq $i (Sub1 (len $idx.Fields)) }}
			{{$type}}_{{$f}}.In({{ $f | LowerInitial }}s...),
					{{- else }}
			{{$type}}_{{$f}}.EQ({{ $f | LowerInitial }}),
					{{- end }}
				{{- end }}
		).
		MustBuild()
	var list {{$list}}
	err := tsq.Trace(ctx, func(ctx context.Context) error {
		var err error
		list, err = tsq.List[{{$type}}](ctx, db, query)
		return errors.Trace(err)
	})
	return list, errors.Trace(err)
}
			{{- end }}
		{{- else }}
			{{- with $query := printf "%s%sQuery" $listActiveBy $idx.Name }}
// {{$query}} queries active (non-deleted) {{$type}} records by index {{$idx.Name}}.
var {{$query}} = tsq.
	Select({{$varTblCols}}...).
	Where(
		{{$type}}_{{$dot.DT}}.EQ(0),
				{{- range $f := $idx.Fields }}
		{{$type}}_{{$f}}.EQVar(),
				{{- end }}
	).
	KwSearch(Table{{$type}}.KwList()...).
	MustBuild()

				{{- with $name := printf "%s%s" $CountActiveBy $idx.Name }}
// {{$name}} returns the count of active (non-deleted) {{$type}} records matching index {{$idx.Name}}.
func {{$name}}(
	ctx context.Context,
	db gorp.SqlExecutor,
					{{- range $f := $idx.Fields }}
	{{$f | LowerInitial}} {{ index $dot.FieldMap $f | FieldType }},
					{{- end }}
) (int, error) {
	query := {{$query}}

	var rs int
	return rs, tsq.Trace(ctx, func(ctx context.Context) error {
		var err error
		rs, err = query.Count(ctx, db,
					{{- range $f := $idx.Fields }}
			{{$f | LowerInitial}},
					{{- end }}
		)
		return errors.Trace(err)
	})
}
				{{- end }}

				{{- with $name := printf "%s%s" $ListActiveBy $idx.Name }}
// {{$name}} retrieves active (non-deleted) {{$type}} records by index {{$idx.Name}}.
func {{$name}}(
	ctx context.Context,
	db gorp.SqlExecutor,
					{{- range $f := $idx.Fields }}
	{{$f | LowerInitial}} {{ index $dot.FieldMap $f | FieldType }},
					{{- end }}
) ({{$list}}, error) {
	query := {{$query}}

	var data {{$list}}
	return data, tsq.Trace(ctx, func(ctx context.Context) error {
		var err error
		data, err = tsq.List[{{$type}}](ctx, db, query,
					{{- range $f := $idx.Fields }}
			{{$f | LowerInitial}},
					{{- end }}
		)
		return errors.Trace(err)
	})
}
				{{- end }}

				{{- with $name := printf "%s%s" $PageActiveBy $idx.Name }}
// {{$name}} retrieves active (non-deleted) {{$type}} records by index {{$idx.Name}} with pagination support.
func {{$name}}(
	ctx context.Context,
	db gorp.SqlExecutor,
	page *tsq.PageReq,
					{{- range $f := $idx.Fields }}
	{{$f | LowerInitial}} {{ index $dot.FieldMap $f | FieldType }},
					{{- end }}
) (*{{$pageResp}}, error) {
	query := {{$query}}

	var rs *{{$pageResp}}
	return rs, tsq.Trace(ctx, func(ctx context.Context) error {
		var err error
		rs, err = tsq.Page[{{$type}}](ctx, db, page, query,
					{{- range $f := $idx.Fields }}
			{{$f | LowerInitial}},
					{{- end }}
		)
		return errors.Trace(err)
	})
}
				{{- end }}
			{{- end }}

		{{- end }}
	{{- end }}
{{- end }}
