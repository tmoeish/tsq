// Code generated by tsq-dev. DO NOT EDIT.
package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/juju/errors"
	"github.com/tmoeish/tsq"
	"gopkg.in/gorp.v2"

	null "gopkg.in/nullbio/null.v6"
)

// =============================================================================
// Table Interface Implementation
// =============================================================================

func init() {
	tsq.RegisterTable(TableItem)
}

// TableItem implements the tsq.Table interface for Item.
var TableItem tsq.Table = Item{}

// TableItemCols is the list of columns for Item table.
var TableItemCols = []tsq.Column{
	Item_CT,
	Item_CategoryID,
	Item_ID,
	Item_Name,
	Item_Price,
}

// Column definitions for Item table.
var (
	Item_CT = tsq.NewCol[null.Time](TableItem, "ct", "ct", func(t any) any {
		return &t.(*Item).CT
	})
	Item_CategoryID = tsq.NewCol[int64](TableItem, "category_id", "CategoryID", func(t any) any {
		return &t.(*Item).CategoryID
	})
	Item_ID = tsq.NewCol[int64](TableItem, "id", "id", func(t any) any {
		return &t.(*Item).ID
	})
	Item_Name = tsq.NewCol[string](TableItem, "name", "Name", func(t any) any {
		return &t.(*Item).Name
	})
	Item_Price = tsq.NewCol[int64](TableItem, "price", "Price", func(t any) any {
		return &t.(*Item).Price
	})
)

// Init initializes the Item table in the database.
func (i Item) Init(db *gorp.DbMap, upsertIndexies bool) error {
	db.AddTableWithName(i, "item").SetKeys(true, "ID")

	if !upsertIndexies {
		return nil
	}

	// Upsert Ux list
	if err := tsq.UpsertIndex(db, "item", true, "ux_name", []string{`name`}); err != nil {
		return errors.Annotatef(err, "upsert ux %s for %s", "ux_name", i.Table())
	}
	// Upsert Idx list
	if err := tsq.UpsertIndex(db, "item", false, "IdxCategory", []string{`category_id`}); err != nil {
		return errors.Annotatef(err, "upsert idx %s for %s", "IdxCategory", i.Table())
	}

	return nil
}

// Table returns the database table name for Item.
func (i Item) Table() string { return "item" }

// KwList returns columns that support keyword search for Item.
func (i Item) KwList() []tsq.Column {
	return []tsq.Column{
		Item_Name,
	}
}

// =============================================================================
// Query by Primary Key
// =============================================================================
var getItemByIDQuery = tsq.
	Select(TableItemCols...).
	Where(Item_ID.EQVar()).
	MustBuild()

// GetItemByID retrieves a Item record by its ID.
// Returns (nil, nil) if the record is not found.
func GetItemByID(
	ctx context.Context,
	db gorp.SqlExecutor,
	id int64,
) (*Item, error) {
	row := &Item{}
	err := getItemByIDQuery.Load(ctx, db, row, id)
	switch errors.Cause(err) {
	case nil:
		return row, nil
	case sql.ErrNoRows:
		return nil, nil
	default:
		return nil, errors.Trace(err)
	}
}

// GetItemByIDOrErr retrieves a Item record by its ID.
// Returns (nil, sql.ErrNoRows) if the record is not found.
func GetItemByIDOrErr(
	ctx context.Context,
	db gorp.SqlExecutor,
	id int64,
) (*Item, error) {
	row := &Item{}
	return row, getItemByIDQuery.Load(ctx, db, row, id)
}

// ListItemByIDIn retrieves multiple Item records by a set of ID values.
// Records not found are silently ignored.
func ListItemByIDIn(
	ctx context.Context,
	db gorp.SqlExecutor,
	ids ...int64,
) ([]*Item, error) {
	query := tsq.
		Select(TableItemCols...).
		Where(Item_ID.In(ids...)).
		MustBuild()

	return tsq.List[Item](ctx, db, query)
}

// ListItemByIDInOrErr retrieves multiple Item records by a set of ID values.
// Returns an error if any of the specified records are not found.
func ListItemByIDInOrErr(
	ctx context.Context,
	db gorp.SqlExecutor,
	ids ...int64,
) ([]*Item, error) {
	idSet := map[int64]bool{}
	for _, i := range ids {
		idSet[i] = true
	}
	query := tsq.
		Select(TableItemCols...).
		Where(Item_ID.In(ids...)).
		MustBuild()

	list, err := tsq.List[Item](ctx, db, query)
	if err != nil {
		return nil, errors.Trace(err)
	}

	for _, i := range list {
		delete(idSet, i.ID)
	}
	if len(idSet) > 0 {
		var missings []int64
		for i := range idSet {
			missings = append(missings, i)
		}
		return nil, errors.Errorf("Item(s) not found: %v", missings)
	}
	return list, nil
}

// =============================================================================
// CRUD Operations
// =============================================================================

// Insert inserts a new Item record into the database.
// Automatically sets creation and modification timestamps if configured.
func (i *Item) Insert(
	ctx context.Context,
	db gorp.SqlExecutor,
) error {
	i.CT = null.TimeFrom(time.Now())
	err := tsq.Insert(ctx, db, i)
	if err != nil {
		return errors.Annotate(err, tsq.PrettyJSON(i))
	}

	return nil
}

// Update updates an existing Item record in the database.
// Automatically updates the modification timestamp if configured.
func (i *Item) Update(
	ctx context.Context,
	db gorp.SqlExecutor,
) error {
	err := tsq.Update(ctx, db, i)
	if err != nil {
		return errors.Annotate(err, tsq.PrettyJSON(i))
	}

	return nil
}

// Delete permanently removes a Item record from the database.
func (i *Item) Delete(
	ctx context.Context,
	db gorp.SqlExecutor,
) error {
	err := tsq.Delete(ctx, db, i)
	if err != nil {
		return errors.Annotate(err, tsq.PrettyJSON(i))
	}

	return nil
}

// ListItemByQuery executes a custom query to retrieve Item records.
func ListItemByQuery(
	ctx context.Context,
	tx gorp.SqlExecutor,
	qb *tsq.Query,
	args ...any,
) ([]*Item, error) {
	return tsq.List[Item](ctx, tx, qb, args...)
}

// PageItemByQuery executes a custom query with pagination to retrieve Item records.
func PageItemByQuery(
	ctx context.Context,
	tx gorp.SqlExecutor,
	page *tsq.PageReq,
	qb *tsq.Query,
	args ...any,
) (*tsq.PageResp[Item], error) {
	return tsq.Page[Item](ctx, tx, page, qb, args...)
}

// =============================================================================
// List All Records
// =============================================================================
// listItemQuery is the base query for retrieving all Item records.
var listItemQuery = tsq.
	Select(TableItemCols...).
	KwSearch(TableItem.KwList()...).
	MustBuild()

// CountItem returns the total count of Item records.
func CountItem(
	ctx context.Context,
	tx gorp.SqlExecutor,
) (int, error) {
	return listItemQuery.Count(ctx, tx)
}

// ListItem retrieves all Item records from the database.
func ListItem(
	ctx context.Context,
	tx gorp.SqlExecutor,
) ([]*Item, error) {
	return tsq.List[Item](ctx, tx, listItemQuery)
}

// PageItem retrieves Item records with pagination support.
func PageItem(
	ctx context.Context,
	tx gorp.SqlExecutor,
	page *tsq.PageReq,
) (*tsq.PageResp[Item], error) {
	return tsq.Page[Item](ctx, tx, page, listItemQuery)
}

// =============================================================================
// Query by Unique Indexes
// =============================================================================
var getItemByNameQuery = tsq.
	Select(TableItemCols...).
	Where(
		Item_Name.EQVar(),
	).
	KwSearch(TableItem.KwList()...).
	MustBuild()

// GetItemByName retrieves a Item record by unique index ux_name.
// Returns (nil, nil) if the record is not found.
func GetItemByName(
	ctx context.Context,
	db gorp.SqlExecutor,
	name string,
) (*Item, error) {
	query := getItemByNameQuery

	row := &Item{}
	err := query.Load(ctx, db, row,
		name,
	)
	switch errors.Cause(err) {
	case nil:
		return row, nil
	case sql.ErrNoRows:
		return nil, nil
	default:
		return nil, errors.Trace(err)
	}
}

// GetItemByNameOrErr retrieves a Item record by unique index ux_name.
// Returns (nil, sql.ErrNoRows) if the record is not found.
func GetItemByNameOrErr(
	ctx context.Context,
	db gorp.SqlExecutor,
	name string,
) (*Item, error) {
	query := getItemByNameQuery

	row := &Item{}
	err := query.Load(ctx, db, row,
		name,
	)
	return row, errors.Trace(err)
}

// ExistsItemByName checks whether a Item record exists by unique index ux_name.
func ExistsItemByName(
	ctx context.Context,
	db gorp.SqlExecutor,
	name string,
) (bool, error) {
	query := getItemByNameQuery

	rs, err := query.Exists(ctx, db,
		name,
	)
	return rs, errors.Trace(err)
}

// =============================================================================
// Query by Indexes
// =============================================================================
// ListItemByCategoryIDQuery queries Item records by index CategoryID.
var ListItemByCategoryIDQuery = tsq.
	Select(TableItemCols...).
	Where(
		Item_CategoryID.EQVar(),
	).
	KwSearch(TableItem.KwList()...).
	MustBuild()

// CountItemByCategoryID returns the count of Item records matching index CategoryID.
func CountItemByCategoryID(
	ctx context.Context,
	db gorp.SqlExecutor,
	categoryID int64,
) (int, error) {
	query := ListItemByCategoryIDQuery

	rs, err := query.Count(ctx, db,
		categoryID,
	)
	return rs, errors.Trace(err)
}

// ListItemByCategoryID retrieves Item records by index CategoryID.
func ListItemByCategoryID(
	ctx context.Context,
	db gorp.SqlExecutor,
	categoryID int64,
) ([]*Item, error) {
	query := ListItemByCategoryIDQuery

	data, err := tsq.List[Item](ctx, db, query,
		categoryID,
	)
	return data, errors.Trace(err)
}

// PageItemByCategoryID retrieves Item records by index CategoryID with pagination support.
func PageItemByCategoryID(
	ctx context.Context,
	db gorp.SqlExecutor,
	page *tsq.PageReq,
	categoryID int64,
) (*tsq.PageResp[Item], error) {
	query := ListItemByCategoryIDQuery

	rs, err := tsq.Page[Item](ctx, db, page, query,
		categoryID,
	)
	return rs, errors.Trace(err)
}

// ListItemByCategoryIDIn retrieves Item records by index CategoryIDIn using IN clause for batch querying.
func ListItemByCategoryIDIn(
	ctx context.Context,
	db gorp.SqlExecutor,
	categoryIDs ...int64,
) ([]*Item, error) {
	query := tsq.
		Select(TableItemCols...).
		Where(
			Item_CategoryID.In(categoryIDs...),
		).
		MustBuild()
	list, err := tsq.List[Item](ctx, db, query)
	return list, errors.Trace(err)
}
