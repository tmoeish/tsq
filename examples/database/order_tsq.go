// Code generated by tsq-dev. DO NOT EDIT.
package database

import (
	"context"
	"database/sql"
	time "time"

	"github.com/juju/errors"
	"github.com/tmoeish/tsq"
	"gopkg.in/gorp.v2"

	null "gopkg.in/nullbio/null.v6"
)

// =============================================================================
// Table Interface Implementation
// =============================================================================

func init() {
	tsq.RegisterTable(
		TableOrder,
		func(db *gorp.DbMap) {
			db.AddTableWithName(TableOrder, "order").SetKeys(true, "UID").SetVersionCol("V")
		},
		func(db *gorp.DbMap) error {
			// Upsert Idx list
			if err := tsq.UpsertIndex(db, "order", false, "idx_item", []string{`dt`, `item_id`}); err != nil {
				return errors.Annotate(err, "upsert idx_item@order")
			}
			if err := tsq.UpsertIndex(db, "order", false, "idx_user_id_item_id", []string{`dt`, `user_id`, `item_id`}); err != nil {
				return errors.Annotate(err, "upsert idx_user_id_item_id@order")
			}

			return nil
		},
	)
}

// TableOrder implements the tsq.Table interface for Order.
var TableOrder tsq.Table = Order{}

// TableOrderCols is the list of columns for Order table.
var TableOrderCols = []tsq.Column{
	Order_Amount,
	Order_CT,
	Order_DT,
	Order_ItemID,
	Order_ModifiedTime,
	Order_Price,
	Order_Status,
	Order_UID,
	Order_UserID,
	Order_V,
}

// Column definitions for Order table.
var (
	Order_Amount       = tsq.NewCol[int64](TableOrder, "amount", "Amount", func(t any) any { return &t.(*Order).Amount })
	Order_CT           = tsq.NewCol[time.Time](TableOrder, "ct", "ct", func(t any) any { return &t.(*Order).CT })
	Order_DT           = tsq.NewCol[int64](TableOrder, "dt", "dt", func(t any) any { return &t.(*Order).DT })
	Order_ItemID       = tsq.NewCol[int64](TableOrder, "item_id", "ItemID", func(t any) any { return &t.(*Order).ItemID })
	Order_ModifiedTime = tsq.NewCol[null.Time](TableOrder, "modified_time", "modified_time", func(t any) any { return &t.(*Order).ModifiedTime })
	Order_Price        = tsq.NewCol[int64](TableOrder, "price", "Price", func(t any) any { return &t.(*Order).Price })
	Order_Status       = tsq.NewCol[OrderStatus](TableOrder, "status", "Status", func(t any) any { return &t.(*Order).Status })
	Order_UID          = tsq.NewCol[int64](TableOrder, "uid", "uid", func(t any) any { return &t.(*Order).UID })
	Order_UserID       = tsq.NewCol[int64](TableOrder, "user_id", "UserID", func(t any) any { return &t.(*Order).UserID })
	Order_V            = tsq.NewCol[int64](TableOrder, "v", "v", func(t any) any { return &t.(*Order).V })
)

// Table returns the database table name for Order.
func (o Order) Table() string { return "order" }

// KwList returns columns that support keyword search for Order.
func (o Order) KwList() []tsq.Column {
	return []tsq.Column{}
}

// Active returns true if the Order record is not soft-deleted.
func (o *Order) Active() bool {
	return o.DT == 0
}

// =============================================================================
// Query by Primary Key
// =============================================================================
var getOrderByUIDQuery = tsq.
	Select(TableOrderCols...).
	Where(Order_UID.EQVar()).
	MustBuild()

// GetOrderByUID retrieves a Order record by its UID.
// Returns (nil, nil) if the record is not found.
func GetOrderByUID(
	ctx context.Context,
	db gorp.SqlExecutor,
	uid int64,
) (*Order, error) {
	row := &Order{}
	err := getOrderByUIDQuery.Load(ctx, db, row, uid)
	switch errors.Cause(err) {
	case nil:
		return row, nil
	case sql.ErrNoRows:
		return nil, nil
	default:
		return nil, errors.Trace(err)
	}
}

// GetOrderByUIDOrErr retrieves a Order record by its UID.
// Returns (nil, sql.ErrNoRows) if the record is not found.
func GetOrderByUIDOrErr(
	ctx context.Context,
	db gorp.SqlExecutor,
	uid int64,
) (*Order, error) {
	row := &Order{}
	return row, getOrderByUIDQuery.Load(ctx, db, row, uid)
}

// ListOrderByUIDIn retrieves multiple Order records by a set of UID values.
// Records not found are silently ignored.
func ListOrderByUIDIn(
	ctx context.Context,
	db gorp.SqlExecutor,
	uids ...int64,
) ([]*Order, error) {
	query := tsq.
		Select(TableOrderCols...).
		Where(Order_UID.In(uids...)).
		MustBuild()

	return tsq.List[Order](ctx, db, query)
}

// ListOrderByUIDInOrErr retrieves multiple Order records by a set of UID values.
// Returns an error if any of the specified records are not found.
func ListOrderByUIDInOrErr(
	ctx context.Context,
	db gorp.SqlExecutor,
	uids ...int64,
) ([]*Order, error) {
	uidSet := map[int64]bool{}
	for _, i := range uids {
		uidSet[i] = true
	}
	query := tsq.
		Select(TableOrderCols...).
		Where(Order_UID.In(uids...)).
		MustBuild()

	list, err := tsq.List[Order](ctx, db, query)
	if err != nil {
		return nil, errors.Trace(err)
	}

	for _, i := range list {
		delete(uidSet, i.UID)
	}
	if len(uidSet) > 0 {
		var missings []int64
		for i := range uidSet {
			missings = append(missings, i)
		}
		return nil, errors.Errorf("Order(s) not found: %v", missings)
	}
	return list, nil
}

// =============================================================================
// Query Active Records by Primary Key
// =============================================================================
var getActiveOrderByUIDQuery = tsq.
	Select(TableOrderCols...).
	Where(
		Order_DT.EQ(0),
		Order_UID.EQVar(),
	).
	MustBuild()

// GetActiveOrderByUID retrieves an active (non-deleted) Order record by its UID.
// Returns (nil, nil) if the record is not found or has been soft-deleted.
func GetActiveOrderByUID(
	ctx context.Context,
	db gorp.SqlExecutor,
	uid int64,
) (*Order, error) {
	row := &Order{}
	err := getActiveOrderByUIDQuery.Load(ctx, db, row, uid)
	switch errors.Cause(err) {
	case nil:
		return row, nil
	case sql.ErrNoRows:
		return nil, nil
	default:
		return nil, errors.Trace(err)
	}
}

// GetActiveOrderByUIDOrErr retrieves an active (non-deleted) Order record by its UID.
// Returns (nil, sql.ErrNoRows) if the record is not found or has been soft-deleted.
func GetActiveOrderByUIDOrErr(
	ctx context.Context,
	db gorp.SqlExecutor,
	uid int64,
) (*Order, error) {
	row := &Order{}
	err := getActiveOrderByUIDQuery.Load(ctx, db, row, uid)
	return row, errors.Trace(err)
}

// ListActiveOrderByUIDIn retrieves multiple active (non-deleted) Order records by a set of UID values.
// Records not found or soft-deleted are silently ignored.
func ListActiveOrderByUIDIn(
	ctx context.Context,
	db gorp.SqlExecutor,
	uids ...int64,
) ([]*Order, error) {
	query := tsq.
		Select(TableOrderCols...).
		Where(
			Order_DT.EQ(0),
			Order_UID.In(uids...),
		).
		MustBuild()
	list, err := tsq.List[Order](ctx, db, query)
	if err != nil {
		return nil, errors.Trace(err)
	}
	return list, nil
}

// ListActiveOrderByUIDInOrErr retrieves multiple active (non-deleted) Order records by a set of UID values.
// Returns an error if any of the specified active records are not found.
func ListActiveOrderByUIDInOrErr(
	ctx context.Context,
	db gorp.SqlExecutor,
	uids ...int64,
) ([]*Order, error) {
	uidSet := map[int64]bool{}
	for _, i := range uids {
		uidSet[i] = true
	}
	query := tsq.
		Select(TableOrderCols...).
		Where(
			Order_DT.EQ(0),
			Order_UID.In(uids...),
		).
		MustBuild()

	var list []*Order
	list, err := tsq.List[Order](ctx, db, query)
	if err != nil {
		return nil, errors.Trace(err)
	}
	for _, i := range list {
		delete(uidSet, i.UID)
	}
	if len(uidSet) > 0 {
		var missings []int64
		for i := range uidSet {
			missings = append(missings, i)
		}
		return nil, errors.Errorf("Order(s) not found: %v", missings)
	}
	return list, nil
}

// =============================================================================
// CRUD Operations
// =============================================================================

// Insert inserts a new Order record into the database.
// Automatically sets creation and modification timestamps if configured.
func (o *Order) Insert(
	ctx context.Context,
	db gorp.SqlExecutor,
) error {
	o.CT = time.Now()
	o.ModifiedTime = null.TimeFrom(time.Now())
	err := tsq.Insert(ctx, db, o)
	if err != nil {
		return errors.Annotate(err, tsq.PrettyJSON(o))
	}

	return nil
}

// Update updates an existing Order record in the database.
// Automatically updates the modification timestamp if configured.
func (o *Order) Update(
	ctx context.Context,
	db gorp.SqlExecutor,
) error {
	o.ModifiedTime = null.TimeFrom(time.Now())
	err := tsq.Update(ctx, db, o)
	if err != nil {
		return errors.Annotate(err, tsq.PrettyJSON(o))
	}

	return nil
}

// Delete permanently removes a Order record from the database.
func (o *Order) Delete(
	ctx context.Context,
	db gorp.SqlExecutor,
) error {
	err := tsq.Delete(ctx, db, o)
	if err != nil {
		return errors.Annotate(err, tsq.PrettyJSON(o))
	}

	return nil
}

// SoftDelete marks a Order record as deleted without removing it from the database.
// If dt > 0, uses the provided timestamp; otherwise uses the current time.
func (o *Order) SoftDelete(
	ctx context.Context,
	db gorp.SqlExecutor,
	dt int64,
) error {
	if dt > 0 {
		o.DT = dt
	} else {
		o.DT = time.Now().UnixNano()
	}
	o.ModifiedTime = null.TimeFrom(time.Now())
	err := tsq.Update(ctx, db, o)
	if err != nil {
		return errors.Annotate(err, tsq.PrettyJSON(o))
	}

	return nil
}

// ListOrderByQuery executes a custom query to retrieve Order records.
func ListOrderByQuery(
	ctx context.Context,
	tx gorp.SqlExecutor,
	qb *tsq.Query,
	args ...any,
) ([]*Order, error) {
	return tsq.List[Order](ctx, tx, qb, args...)
}

// PageOrderByQuery executes a custom query with pagination to retrieve Order records.
func PageOrderByQuery(
	ctx context.Context,
	tx gorp.SqlExecutor,
	page *tsq.PageReq,
	qb *tsq.Query,
	args ...any,
) (*tsq.PageResp[Order], error) {
	return tsq.Page[Order](ctx, tx, page, qb, args...)
}

// =============================================================================
// List All Records
// =============================================================================
// listOrderQuery is the base query for retrieving all Order records.
var listOrderQuery = tsq.
	Select(TableOrderCols...).
	KwSearch(TableOrder.KwList()...).
	MustBuild()

// CountOrder returns the total count of Order records.
func CountOrder(
	ctx context.Context,
	tx gorp.SqlExecutor,
) (int, error) {
	return listOrderQuery.Count(ctx, tx)
}

// ListOrder retrieves all Order records from the database.
func ListOrder(
	ctx context.Context,
	tx gorp.SqlExecutor,
) ([]*Order, error) {
	return tsq.List[Order](ctx, tx, listOrderQuery)
}

// PageOrder retrieves Order records with pagination support.
func PageOrder(
	ctx context.Context,
	tx gorp.SqlExecutor,
	page *tsq.PageReq,
) (*tsq.PageResp[Order], error) {
	return tsq.Page[Order](ctx, tx, page, listOrderQuery)
}

// =============================================================================
// List Active Records
// =============================================================================
// listActiveOrderQuery is the base query for retrieving active (non-deleted) Order records.
var listActiveOrderQuery = tsq.
	Select(TableOrderCols...).
	Where(Order_DT.EQ(0)).
	KwSearch(TableOrder.KwList()...).
	MustBuild()

// CountActiveOrder returns the count of active (non-deleted) Order records.
func CountActiveOrder(
	ctx context.Context,
	tx gorp.SqlExecutor,
) (int, error) {
	return listActiveOrderQuery.Count(ctx, tx)
}

// ListActiveOrder retrieves all active (non-deleted) Order records.
func ListActiveOrder(
	ctx context.Context,
	tx gorp.SqlExecutor,
) ([]*Order, error) {
	return tsq.List[Order](ctx, tx, listActiveOrderQuery)
}

// PageActiveOrder retrieves active (non-deleted) Order records with pagination support.
func PageActiveOrder(
	ctx context.Context,
	tx gorp.SqlExecutor,
	page *tsq.PageReq,
) (*tsq.PageResp[Order], error) {
	return tsq.Page[Order](ctx, tx, page, listActiveOrderQuery)
}

// =============================================================================
// Query by Unique Indexes
// =============================================================================
// =============================================================================
// Query Active Records by Unique Indexes
// =============================================================================
// =============================================================================
// Query by Indexes
// =============================================================================
// ListOrderByItemIDQuery queries Order records by index ItemID.
var ListOrderByItemIDQuery = tsq.
	Select(TableOrderCols...).
	Where(
		Order_ItemID.EQVar(),
	).
	KwSearch(TableOrder.KwList()...).
	MustBuild()

// CountOrderByItemID returns the count of Order records matching index ItemID.
func CountOrderByItemID(
	ctx context.Context,
	db gorp.SqlExecutor,
	itemID int64,
) (int, error) {
	query := ListOrderByItemIDQuery

	rs, err := query.Count(ctx, db,
		itemID,
	)
	return rs, errors.Trace(err)
}

// ListOrderByItemID retrieves Order records by index ItemID.
func ListOrderByItemID(
	ctx context.Context,
	db gorp.SqlExecutor,
	itemID int64,
) ([]*Order, error) {
	query := ListOrderByItemIDQuery

	data, err := tsq.List[Order](ctx, db, query,
		itemID,
	)
	return data, errors.Trace(err)
}

// PageOrderByItemID retrieves Order records by index ItemID with pagination support.
func PageOrderByItemID(
	ctx context.Context,
	db gorp.SqlExecutor,
	page *tsq.PageReq,
	itemID int64,
) (*tsq.PageResp[Order], error) {
	query := ListOrderByItemIDQuery

	rs, err := tsq.Page[Order](ctx, db, page, query,
		itemID,
	)
	return rs, errors.Trace(err)
}

// ListOrderByItemIDIn retrieves Order records by index ItemIDIn using IN clause for batch querying.
func ListOrderByItemIDIn(
	ctx context.Context,
	db gorp.SqlExecutor,
	itemIDs ...int64,
) ([]*Order, error) {
	query := tsq.
		Select(TableOrderCols...).
		Where(
			Order_ItemID.In(itemIDs...),
		).
		MustBuild()
	list, err := tsq.List[Order](ctx, db, query)
	return list, errors.Trace(err)
}

// ListOrderByUserIDQuery queries Order records by index UserID.
var ListOrderByUserIDQuery = tsq.
	Select(TableOrderCols...).
	Where(
		Order_UserID.EQVar(),
	).
	KwSearch(TableOrder.KwList()...).
	MustBuild()

// CountOrderByUserID returns the count of Order records matching index UserID.
func CountOrderByUserID(
	ctx context.Context,
	db gorp.SqlExecutor,
	userID int64,
) (int, error) {
	query := ListOrderByUserIDQuery

	rs, err := query.Count(ctx, db,
		userID,
	)
	return rs, errors.Trace(err)
}

// ListOrderByUserID retrieves Order records by index UserID.
func ListOrderByUserID(
	ctx context.Context,
	db gorp.SqlExecutor,
	userID int64,
) ([]*Order, error) {
	query := ListOrderByUserIDQuery

	data, err := tsq.List[Order](ctx, db, query,
		userID,
	)
	return data, errors.Trace(err)
}

// PageOrderByUserID retrieves Order records by index UserID with pagination support.
func PageOrderByUserID(
	ctx context.Context,
	db gorp.SqlExecutor,
	page *tsq.PageReq,
	userID int64,
) (*tsq.PageResp[Order], error) {
	query := ListOrderByUserIDQuery

	rs, err := tsq.Page[Order](ctx, db, page, query,
		userID,
	)
	return rs, errors.Trace(err)
}

// ListOrderByUserIDAndItemIDQuery queries Order records by index UserIDAndItemID.
var ListOrderByUserIDAndItemIDQuery = tsq.
	Select(TableOrderCols...).
	Where(
		Order_UserID.EQVar(),
		Order_ItemID.EQVar(),
	).
	KwSearch(TableOrder.KwList()...).
	MustBuild()

// CountOrderByUserIDAndItemID returns the count of Order records matching index UserIDAndItemID.
func CountOrderByUserIDAndItemID(
	ctx context.Context,
	db gorp.SqlExecutor,
	userID int64,
	itemID int64,
) (int, error) {
	query := ListOrderByUserIDAndItemIDQuery

	rs, err := query.Count(ctx, db,
		userID,
		itemID,
	)
	return rs, errors.Trace(err)
}

// ListOrderByUserIDAndItemID retrieves Order records by index UserIDAndItemID.
func ListOrderByUserIDAndItemID(
	ctx context.Context,
	db gorp.SqlExecutor,
	userID int64,
	itemID int64,
) ([]*Order, error) {
	query := ListOrderByUserIDAndItemIDQuery

	data, err := tsq.List[Order](ctx, db, query,
		userID,
		itemID,
	)
	return data, errors.Trace(err)
}

// PageOrderByUserIDAndItemID retrieves Order records by index UserIDAndItemID with pagination support.
func PageOrderByUserIDAndItemID(
	ctx context.Context,
	db gorp.SqlExecutor,
	page *tsq.PageReq,
	userID int64,
	itemID int64,
) (*tsq.PageResp[Order], error) {
	query := ListOrderByUserIDAndItemIDQuery

	rs, err := tsq.Page[Order](ctx, db, page, query,
		userID,
		itemID,
	)
	return rs, errors.Trace(err)
}

// ListOrderByUserIDAndItemIDIn retrieves Order records by index UserIDAndItemIDIn using IN clause for batch querying.
func ListOrderByUserIDAndItemIDIn(
	ctx context.Context,
	db gorp.SqlExecutor,
	userID int64,
	itemIDs ...int64,
) ([]*Order, error) {
	query := tsq.
		Select(TableOrderCols...).
		Where(
			Order_UserID.EQ(userID),
			Order_ItemID.In(itemIDs...),
		).
		MustBuild()
	list, err := tsq.List[Order](ctx, db, query)
	return list, errors.Trace(err)
}

// ListOrderByUserIDIn retrieves Order records by index UserIDIn using IN clause for batch querying.
func ListOrderByUserIDIn(
	ctx context.Context,
	db gorp.SqlExecutor,
	userIDs ...int64,
) ([]*Order, error) {
	query := tsq.
		Select(TableOrderCols...).
		Where(
			Order_UserID.In(userIDs...),
		).
		MustBuild()
	list, err := tsq.List[Order](ctx, db, query)
	return list, errors.Trace(err)
}

// =============================================================================
// Query Active Records by Indexes
// =============================================================================
// listActiveOrderByItemIDQuery queries active (non-deleted) Order records by index ItemID.
var listActiveOrderByItemIDQuery = tsq.
	Select(TableOrderCols...).
	Where(
		Order_DT.EQ(0),
		Order_ItemID.EQVar(),
	).
	KwSearch(TableOrder.KwList()...).
	MustBuild()

// CountActiveOrderByItemID returns the count of active (non-deleted) Order records matching index ItemID.
func CountActiveOrderByItemID(
	ctx context.Context,
	db gorp.SqlExecutor,
	itemID int64,
) (int, error) {
	query := listActiveOrderByItemIDQuery

	rs, err := query.Count(ctx, db,
		itemID,
	)
	return rs, errors.Trace(err)
}

// ListActiveOrderByItemID retrieves active (non-deleted) Order records by index ItemID.
func ListActiveOrderByItemID(
	ctx context.Context,
	db gorp.SqlExecutor,
	itemID int64,
) ([]*Order, error) {
	query := listActiveOrderByItemIDQuery

	data, err := tsq.List[Order](ctx, db, query,
		itemID,
	)
	return data, errors.Trace(err)
}

// PageActiveOrderByItemID retrieves active (non-deleted) Order records by index ItemID with pagination support.
func PageActiveOrderByItemID(
	ctx context.Context,
	db gorp.SqlExecutor,
	page *tsq.PageReq,
	itemID int64,
) (*tsq.PageResp[Order], error) {
	query := listActiveOrderByItemIDQuery

	rs, err := tsq.Page[Order](ctx, db, page, query,
		itemID,
	)
	return rs, errors.Trace(err)
}

// ListActiveOrderByItemIDIn retrieves active (non-deleted) Order records by index ItemIDIn using IN clause for batch querying.
func ListActiveOrderByItemIDIn(
	ctx context.Context,
	db gorp.SqlExecutor,
	itemIDs ...int64,
) ([]*Order, error) {
	query := tsq.
		Select(TableOrderCols...).
		Where(
			Order_DT.EQ(0),
			Order_ItemID.In(itemIDs...),
		).
		MustBuild()
	list, err := tsq.List[Order](ctx, db, query)
	return list, errors.Trace(err)
}

// listActiveOrderByUserIDQuery queries active (non-deleted) Order records by index UserID.
var listActiveOrderByUserIDQuery = tsq.
	Select(TableOrderCols...).
	Where(
		Order_DT.EQ(0),
		Order_UserID.EQVar(),
	).
	KwSearch(TableOrder.KwList()...).
	MustBuild()

// CountActiveOrderByUserID returns the count of active (non-deleted) Order records matching index UserID.
func CountActiveOrderByUserID(
	ctx context.Context,
	db gorp.SqlExecutor,
	userID int64,
) (int, error) {
	query := listActiveOrderByUserIDQuery

	rs, err := query.Count(ctx, db,
		userID,
	)
	return rs, errors.Trace(err)
}

// ListActiveOrderByUserID retrieves active (non-deleted) Order records by index UserID.
func ListActiveOrderByUserID(
	ctx context.Context,
	db gorp.SqlExecutor,
	userID int64,
) ([]*Order, error) {
	query := listActiveOrderByUserIDQuery

	data, err := tsq.List[Order](ctx, db, query,
		userID,
	)
	return data, errors.Trace(err)
}

// PageActiveOrderByUserID retrieves active (non-deleted) Order records by index UserID with pagination support.
func PageActiveOrderByUserID(
	ctx context.Context,
	db gorp.SqlExecutor,
	page *tsq.PageReq,
	userID int64,
) (*tsq.PageResp[Order], error) {
	query := listActiveOrderByUserIDQuery

	rs, err := tsq.Page[Order](ctx, db, page, query,
		userID,
	)
	return rs, errors.Trace(err)
}

// listActiveOrderByUserIDAndItemIDQuery queries active (non-deleted) Order records by index UserIDAndItemID.
var listActiveOrderByUserIDAndItemIDQuery = tsq.
	Select(TableOrderCols...).
	Where(
		Order_DT.EQ(0),
		Order_UserID.EQVar(),
		Order_ItemID.EQVar(),
	).
	KwSearch(TableOrder.KwList()...).
	MustBuild()

// CountActiveOrderByUserIDAndItemID returns the count of active (non-deleted) Order records matching index UserIDAndItemID.
func CountActiveOrderByUserIDAndItemID(
	ctx context.Context,
	db gorp.SqlExecutor,
	userID int64,
	itemID int64,
) (int, error) {
	query := listActiveOrderByUserIDAndItemIDQuery

	rs, err := query.Count(ctx, db,
		userID,
		itemID,
	)
	return rs, errors.Trace(err)
}

// ListActiveOrderByUserIDAndItemID retrieves active (non-deleted) Order records by index UserIDAndItemID.
func ListActiveOrderByUserIDAndItemID(
	ctx context.Context,
	db gorp.SqlExecutor,
	userID int64,
	itemID int64,
) ([]*Order, error) {
	query := listActiveOrderByUserIDAndItemIDQuery

	data, err := tsq.List[Order](ctx, db, query,
		userID,
		itemID,
	)
	return data, errors.Trace(err)
}

// PageActiveOrderByUserIDAndItemID retrieves active (non-deleted) Order records by index UserIDAndItemID with pagination support.
func PageActiveOrderByUserIDAndItemID(
	ctx context.Context,
	db gorp.SqlExecutor,
	page *tsq.PageReq,
	userID int64,
	itemID int64,
) (*tsq.PageResp[Order], error) {
	query := listActiveOrderByUserIDAndItemIDQuery

	rs, err := tsq.Page[Order](ctx, db, page, query,
		userID,
		itemID,
	)
	return rs, errors.Trace(err)
}

// ListActiveOrderByUserIDAndItemIDIn retrieves active (non-deleted) Order records by index UserIDAndItemIDIn using IN clause for batch querying.
func ListActiveOrderByUserIDAndItemIDIn(
	ctx context.Context,
	db gorp.SqlExecutor,
	userID int64,
	itemIDs ...int64,
) ([]*Order, error) {
	query := tsq.
		Select(TableOrderCols...).
		Where(
			Order_DT.EQ(0),
			Order_UserID.EQ(userID),
			Order_ItemID.In(itemIDs...),
		).
		MustBuild()
	list, err := tsq.List[Order](ctx, db, query)
	return list, errors.Trace(err)
}

// ListActiveOrderByUserIDIn retrieves active (non-deleted) Order records by index UserIDIn using IN clause for batch querying.
func ListActiveOrderByUserIDIn(
	ctx context.Context,
	db gorp.SqlExecutor,
	userIDs ...int64,
) ([]*Order, error) {
	query := tsq.
		Select(TableOrderCols...).
		Where(
			Order_DT.EQ(0),
			Order_UserID.In(userIDs...),
		).
		MustBuild()
	list, err := tsq.List[Order](ctx, db, query)
	return list, errors.Trace(err)
}
